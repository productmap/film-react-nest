name: CD Pipeline

on:
  workflow_run:
    workflows: [ "CI Pipeline" ]
    types:
      - completed

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'push' && github.event.workflow_run.head_branch == 'review-2'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Yandex Cloud CLI
        uses: okar1/yc-cli-install@master
        with:
          SA_KEY: ${{ secrets.YC_SA_KEY_JSON }}

      - name: Configure Yandex Cloud Profile
        run: |
          yc config set folder-id ${{ secrets.YC_FOLDER_ID }}
          yc config set compute-default-zone ${{ secrets.YC_ZONE_ID }}  # Это валидное поле
          yc version 

      - name: Create or update VM
        id: vm
        run: |
          VM_NAME="film-nest-vm"
          if yc compute instance get --name "$VM_NAME" >/dev/null 2>&1; then
            echo "VM exists, recreating..."
            yc compute instance delete --name "$VM_NAME"
          fi
          echo "Creating new VM..."
            yc compute instance create \
              --name "$VM_NAME" \
              --zone "${{ secrets.YC_ZONE_ID }}" \
              --network-interface subnet-id="${{ secrets.YC_SUBNET_ID }}",nat-ip-version=ipv4 \
              --memory 2 \
              --cores 2 \
              --create-boot-disk image-id=fd80mrhj8fl2oe87o4e1,size=10GB \
              --service-account-name "${{ secrets.YC_SA_NAME }}"
            yc compute instance add-labels "$VM_NAME" --labels=deploy-ready=true
          fi
          echo "Waiting for VM to get ready and assign IP..."
          sleep 15
          # Получаем внешний IP
          EXTERNAL_IP=$(yc compute instance get "$VM_NAME" --format json | jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat.address')
          echo "external_ip=$EXTERNAL_IP" >> "$GITHUB_OUTPUT"

      - name: Update CloudFlare DNS A Record
        run: |
          ZONE_ID="${{ secrets.CLOUDFLARE_ZONE_ID }}"
          RECORD_NAME="${{ secrets.CLOUDFLARE_DNS_RECORD_NAME }}"
          API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          NEW_IP="${{ steps.vm.outputs.external_ip }}"
          
          # Получаем ID существующей A-записи
          RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$RECORD_NAME&type=A" \
            -H "Authorization: Bearer $API_TOKEN" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')
          
          if [ -n "$RECORD_ID" ]; then
            # Обновляем запись
            curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$RECORD_NAME\",\"content\":\"$NEW_IP\",\"ttl\":1,\"proxied\":false}"
          else
            echo "Record not found, creating new..."
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
              -H "Authorization: Bearer $API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$RECORD_NAME\",\"content\":\"$NEW_IP\",\"ttl\":1,\"proxied\":false}"
          fi
          echo "DNS updated to $NEW_IP"

      - name: Copy files to VM and Deploy
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          source: "docker-compose.yandex.yml,.env,postgres/"
          target: "/home/${{ secrets.SSH_USERNAME }}/film-nest-prod"

      - name: Deploy to VM and setup Certbot
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            # Аутентификация в Yandex Container Registry
            echo '${{ secrets.YC_SA_KEY_JSON }}' | docker login --username json_key --password-stdin cr.yandex

            # Переход в директорию проекта
            cd /home/${{ secrets.SSH_USERNAME }}/film-nest-prod

            # Остановка и удаление существующих контейнеров
            docker compose -f docker-compose.yandex.yml down

            # Запуск сервисов
            IMAGE_TAG=${{ github.sha }} docker compose -f docker-compose.yandex.yml up -d

            # Получение или обновление сертификатов через Certbot (используя DOMAIN_NAME из .env)
            docker compose -f docker-compose.yandex.yml run --rm certbot certonly \
              --webroot \
              --webroot-path=/var/www/certbot \
              --email "${{ secrets.CERTBOT_EMAIL }}" \
              --agree-tos \
              --no-eff-email \
              -d "${{ secrets.DOMAIN_NAME }}"

            # Перезапуск nginx
            docker compose -f docker-compose.yandex.yml restart nginx

            # Настройка cron для обновления сертификатов
            echo "0 0,12 * * * root docker compose -f /home/${{ secrets.SSH_USERNAME }}/film-nest-prod/docker-compose.yandex.yml run --rm certbot renew --quiet && docker compose -f /home/${{ secrets.SSH_USERNAME }}/film-nest-prod/docker-compose.yandex.yml restart nginx" | sudo tee /etc/cron.d/certbot-renew

            # Очистка старых образов (более безопасная)
            docker image prune -a -f --filter "label=stage=prod"
