name: CD Pipeline

on:
  workflow_run:
    workflows: [ "CI Pipeline" ]
    types:
      - completed

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'push' && github.event.workflow_run.head_branch == 'review-2'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Yandex Cloud CLI
        uses: okar1/yc-cli-install@master
        with:
          SA_KEY: ${{ secrets.YC_SA_KEY_JSON }}

      - name: Configure Yandex Cloud Profile
        run: |
          yc config set folder-id ${{ secrets.YC_FOLDER_ID }}
          yc config set compute-default-zone ${{ secrets.YC_ZONE_ID }}  # Это валидное поле
          yc version 

      - name: Create or update VM
        id: vm
        run: |
          VM_NAME="film-nest-vm"
          if yc compute instance get --name "$VM_NAME" >/dev/null 2>&1; then
            echo "VM exists, recreating..."
            yc compute instance delete --name "$VM_NAME"
          fi
          echo "Creating new VM..."
          yc compute instance create \
            --name "$VM_NAME" \
            --zone "${{ secrets.YC_ZONE_ID }}" \
            --network-interface subnet-id="${{ secrets.YC_SUBNET_ID }}",nat-ip-version=ipv4 \
            --memory 2 \
            --cores 2 \
            --create-boot-disk image-folder-id=standard-images,image-family=ubuntu-2204-lts,size=10GB \
            --service-account-name "${{ secrets.YC_SA_NAME }}" \
            --metadata "ssh-keys=${{ secrets.SSH_USERNAME }}:${{ secrets.SSH_PUBLIC_KEY }}"
          yc compute instance add-labels "$VM_NAME" --labels=deploy-ready=true
          echo "Waiting 60 seconds for VM to boot and SSH server to start..."
          sleep 60
          # Получаем внешний IP
          EXTERNAL_IP=$(yc compute instance get "$VM_NAME" --format json | jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat.address')
          echo "external_ip=$EXTERNAL_IP" >> "$GITHUB_OUTPUT"

      - name: Update CloudFlare DNS A Record
        run: |
          ZONE_ID="${{ secrets.CLOUDFLARE_ZONE_ID }}"
          RECORD_NAME="${{ secrets.CLOUDFLARE_DNS_RECORD_NAME }}"
          API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          NEW_IP="${{ steps.vm.outputs.external_ip }}"
          
          # Получаем ID существующей A-записи
          RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$RECORD_NAME&type=A" \
            -H "Authorization: Bearer $API_TOKEN" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')
          
          if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
            # Обновляем запись
            echo "Updating existing DNS record..."
            curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$RECORD_NAME\",\"content\":\"$NEW_IP\",\"ttl\":1,\"proxied\":false}"
          else
            # Создаем новую запись
            echo "DNS record not found, creating new one..."
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
              -H "Authorization: Bearer $API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$RECORD_NAME\",\"content\":\"$NEW_IP\",\"ttl\":1,\"proxied\":false}"
          fi
          echo "DNS updated to $NEW_IP"

      - name: Install Docker on VM
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            echo "### Installing Docker and Docker Compose plugin..."
            sudo apt-get update
            sudo apt-get install -y ca-certificates curl
            sudo install -m 0755 -d /etc/apt/keyrings
            sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
            sudo chmod a+r /etc/apt/keyrings/docker.asc
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
              $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            sudo usermod -aG docker ${{ secrets.SSH_USERNAME }}
            echo "### Creating project directory..."
            mkdir -p /home/${{ secrets.SSH_USERNAME }}/film-nest-prod
            echo "### Docker installed and directory created successfully."

      - name: Create docker-compose.yandex.yml from secret
        run: echo "${{ secrets.DOCKER_COMPOSE_YANDEX_YML }}" > docker-compose.yandex.yml

      - name: Create .env file from secret
        run: echo "${{ secrets.DOTENV }}" > .env

      - name: Create postgres directory and init script
        run: |
          mkdir -p postgres
          echo "${{ secrets.POSTGRES_INIT_SQL }}" > postgres/init.sql

      - name: Copy docker-compose.yandex.yml to VM
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          source: "docker-compose.yandex.yml"
          target: "/home/${{ secrets.SSH_USERNAME }}/film-nest-prod"

      - name: Copy .env to VM
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          source: ".env"
          target: "/home/${{ secrets.SSH_USERNAME }}/film-nest-prod"

      - name: Copy postgres directory to VM
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          source: "postgres/"
          target: "/home/${{ secrets.SSH_USERNAME }}/film-nest-prod"

      - name: Deploy to VM and setup Certbot
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.vm.outputs.external_ip }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            # Аутентификация в Yandex Container Registry
            echo '${{ secrets.YC_SA_KEY_JSON }}' | docker login --username json_key --password-stdin cr.yandex

            # Переход в директорию проекта
            cd /home/${{ secrets.SSH_USERNAME }}/film-nest-prod

            # Остановка и удаление существующих контейнеров
            docker compose -f docker-compose.yandex.yml down

            # Запуск сервисов
            IMAGE_TAG=${{ github.sha }} docker compose -f docker-compose.yandex.yml up -d

            # Получение или обновление сертификатов через Certbot (используя DOMAIN_NAME из .env)
            docker compose -f docker-compose.yandex.yml run --rm certbot certonly \
              --webroot \
              --webroot-path=/var/www/certbot \
              --email "${{ secrets.CERTBOT_EMAIL }}" \
              --agree-tos \
              --no-eff-email \
              -d "${{ secrets.DOMAIN_NAME }}"

            # Перезапуск nginx
            docker compose -f docker-compose.yandex.yml restart nginx

            # Настройка cron для обновления сертификатов
            echo "0 0,12 * * * root docker compose -f /home/${{ secrets.SSH_USERNAME }}/film-nest-prod/docker-compose.yandex.yml run --rm certbot renew --quiet && docker compose -f /home/${{ secrets.SSH_USERNAME }}/film-nest-prod/docker-compose.yandex.yml restart nginx" | sudo tee /etc/cron.d/certbot-renew

            # Очистка старых образов (более безопасная)
            docker image prune -a -f --filter "label=stage=prod"